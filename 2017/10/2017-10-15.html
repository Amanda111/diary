<!DOCTYPE html><!--[if lte IE 8]>
<html lang="en" class="lte-ie8">
<![endif]-->
<!--[if gt IE 8]><!-->
<html lang="en">
<!--<![endif]--><head><meta charset="utf-8"><title>October 15, 2017</title><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/diary/styles/global.css"><link rel="stylesheet" href="/diary/styles/tomorrow.css"><link rel="stylesheet" href="/diary/styles/diary.css"></head><body><header class="header"><div class="index"><a href="/diary/">Index</a></div><h1>October 15, 2017</h1></header><div class="content"><div class="diary"><h2 id="-">《忍者秘籍》第四章练习</h2>
<h3 id="ex-1">Ex.1</h3>
<p>The following function calculates the sum of the passed-in arguments by using the arguments object:</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++){
       sum += <span class="hljs-built_in">arguments</span>[i];
    }
    <span class="hljs-keyword">return</span> sum; 
}
</code></pre><p>using the rest parameters rewrite the sum function</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span></span>{
    <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span>;
    args.forEach((i)=&gt;{
        sum += i;
    })
    <span class="hljs-keyword">return</span> sum;
}
</code></pre><h3 id="ex-2">Ex.2</h3>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSamurai</span>(<span class="hljs-params">samurai</span>)</span>{
<span class="hljs-pi">     "use strict"</span>
     <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>] = <span class="hljs-string">"Ishida"</span>;
     <span class="hljs-keyword">return</span> samurai;
   }
   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNinja</span>(<span class="hljs-params">ninja</span>)</span>{
     <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>] = <span class="hljs-string">"Fuma"</span>;
     <span class="hljs-keyword">return</span> ninja;
}
<span class="hljs-keyword">var</span> samurai = getSamurai(<span class="hljs-string">"Toyotomi"</span>); --&gt; Toyotomi
<span class="hljs-keyword">var</span> ninja = getNinja(<span class="hljs-string">"Yoshi"</span>); --&gt; Fuma
</code></pre><p>严格模式下，参数的值不会随 arguments 对象的值的改变而变化。在正常模式下，对于第一个参数是 arg 的函数，对 arg 赋值时会同时赋值给 arguments[0]，反之亦然（除非没有参数，或者 arguments[0] 被删除）。严格模式下，函数的 arguments 对象会保存函数被调用时的原始参数。arguments[i] 的值不会随与之相应的参数的值的改变而变化，同名参数的值也不会随与之相应的 arguments[i] 的值的改变而变化。</p>
<h3 id="ex-3">Ex.3</h3>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">whoAmI1</span>(<span class="hljs-params"></span>)</span>{
<span class="hljs-pi">   "use strict"</span>;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">whoAmI2</span>(<span class="hljs-params"></span>)</span>{
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
}
whoAmI1() === <span class="hljs-built_in">window</span> ---&gt; <span class="hljs-literal">false</span>
whoAmI2() === <span class="hljs-built_in">window</span> ---&gt; <span class="hljs-literal">true</span>
</code></pre><p>在正常模式下，this指向全局；严格模式下，this会是undefined</p>
<h3 id="ex-4">Ex.4</h3>
<pre><code><span class="hljs-keyword">var</span> ninja1 = {
    <span class="hljs-attribute">whoAmI</span>: <span class="hljs-keyword">function</span>(){
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }
};
<span class="hljs-keyword">var</span> ninja2 = {
    <span class="hljs-attribute">whoAmI</span>: ninja1.whoAmI
};

<span class="hljs-keyword">var</span> identify = ninja2.whoAmI;

ninja1.whoAmI() -<span class="hljs-function">--&gt;</span> ninja1
ninja2.whoAmI() -<span class="hljs-function">--&gt;</span> ninja2
identify() -<span class="hljs-function">--&gt;</span> <span class="hljs-built_in">window</span>
ninja1.whoAmI.call(ninja2) -<span class="hljs-function">--&gt;</span> ninja2
</code></pre><p>此处引用的是函数别名<code>ninja1.whoAmI</code>和<code>ninja2.whoAmI</code>，与对象嵌套引用无关，相当于直接引用函数。</p>
<h3 id="ex-5">Ex.5</h3>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Ninja</span><span class="hljs-params">()</span></span>{
  <span class="hljs-keyword">this</span>.whoAmI = () =&gt; <span class="hljs-keyword">this</span>;
}
<span class="hljs-keyword">var</span> ninja1 = <span class="hljs-keyword">new</span> Ninja();
<span class="hljs-keyword">var</span> ninja2 = {
  whoAmI: ninja1.whoAmI
};

ninja1.whoAmI() ---&gt; ninja1
ninja2.whoAmI() ---&gt; ninja1
</code></pre><p>在调用Ninja构造函数时，创建了ninja1对象，并将函数内的this绑定在ninja1上，同时函数体内<code>return this</code>也确定了指向ninja1，且不会再改变。</p>
<h3 id="ex-6">Ex.6</h3>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Ninja</span><span class="hljs-params">()</span></span>{
  <span class="hljs-keyword">this</span>.whoAmI = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  }.bind(<span class="hljs-keyword">this</span>); 
}
<span class="hljs-keyword">var</span> ninja1 = <span class="hljs-keyword">new</span> Ninja();
<span class="hljs-keyword">var</span> ninja2 = {
  whoAmI: ninja1.whoAmI <span class="hljs-comment">// 函数别名</span>
};
ninja1.whoAmI() ---&gt; ninja1
ninja2.whoAmI() ---&gt; ninja1
</code></pre><p>优先级：new &gt; 显示绑定 &gt; 隐式绑定(YDKJS P91);</p>
<p>疑问：<code>bind(this)</code> 传入的是window，因为new的优先级更高，改变了this的指向使得<code>this</code>又指向了ninja1；</p>
</div></div><footer class="footer"><address class="author">Copyright &copy;<a rel="author" href="https://github.com/Amanda111" class="author-name">Amanda</a>-<a href="https://github.com/Amanda111/my-tech-diary" class="source-repo">Source</a></address></footer></body></html>