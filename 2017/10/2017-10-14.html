<!DOCTYPE html><!--[if lte IE 8]>
<html lang="en" class="lte-ie8">
<![endif]-->
<!--[if gt IE 8]><!-->
<html lang="en">
<!--<![endif]--><head><meta charset="utf-8"><title>October 14, 2017</title><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/diary/styles/global.css"><link rel="stylesheet" href="/diary/styles/tomorrow.css"><link rel="stylesheet" href="/diary/styles/diary.css"></head><body><header class="header"><div class="index"><a href="/diary/">Index</a></div><h1>October 14, 2017</h1></header><div class="content"><div class="diary"><h2 id="-this-in-javascript">&#39;this&#39; in javascript</h2>
<p>当一个函数被调用时，会创建执行上下文，并隐式绑定<code>this</code>来指向它。<code>this</code>是函数运行时传入的参数，其指向主要由函数调用的方式决定。</p>
<h3 id="-">函数调用的方式</h3>
<h4 id="1-">1、作为函数</h4>
<p>在非严格模式下，<code>this</code>指向全局；严格模式下，<code>this</code>会是undefined</p>
<pre><code><span class="hljs-keyword">function</span> foo(){
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a)
}

<span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>

foo<span class="hljs-function"><span class="hljs-params">()</span> --&gt;</span> <span class="hljs-number">2</span>
</code></pre><pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>{
<span class="hljs-pi">    "use strict"</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a)
}

<span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>

foo() --&gt; <span class="hljs-built_in">TypeError</span>: <span class="hljs-keyword">this</span> is <span class="hljs-literal">undefined</span>
</code></pre><h4 id="2-">2、作为对象的方法</h4>
<p>当函数的调用位置在对象内时，会使用obj的上下文来引用函数。此时，函数调用中的<code>this</code>将绑定这个上下文对象。若对象存在嵌套引用，则对象属性引用中只有上一层或最后一层在调用位置中起作用。</p>
<pre><code><span class="hljs-keyword">function</span> foo(){
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a)
}

<span class="hljs-keyword">var</span> obj = {
    <span class="hljs-attribute">a</span>:<span class="hljs-number">2</span>,
    <span class="hljs-attribute">foo</span>:foo
}

obj.foo<span class="hljs-function"><span class="hljs-params">()</span> --&gt;</span> <span class="hljs-number">2</span>
</code></pre><h4 id="3-">3、作为构造函数</h4>
<p>在调用构造函数时，会创建一个新的对象，并把它绑定到函数调用的<code>this</code>上。需要注意的是，如果构造函数显式返回一个非空对象，那么构造出来对象将会被抛弃，并暴露显式返回的对象。如果返回的是空对象或不是对象，才返回构造出来的对象。</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-title">num</span>){</span>
    this.<span class="hljs-operator">a</span> = <span class="hljs-built_in">num</span>
}

var bar = <span class="hljs-built_in">new</span> foo(<span class="hljs-number">2</span>)
bar.<span class="hljs-operator">a</span> <span class="hljs-comment">--&gt; 2</span>
</code></pre><h4 id="4-call-apply-">4、call和apply等方法（显式绑定）</h4>
<pre><code><span class="hljs-function">function <span class="hljs-title">foo</span><span class="hljs-params">(num)</span></span>{
    <span class="hljs-keyword">this</span>.count = num
}
foo.count = <span class="hljs-number">0</span>;

foo(<span class="hljs-number">3</span>);
console.<span class="hljs-built_in">log</span>(foo.count) --&gt; <span class="hljs-number">0</span>

foo.call(foo,<span class="hljs-number">3</span>)
console.<span class="hljs-built_in">log</span>(foo.count) ---&gt; <span class="hljs-number">3</span>
</code></pre><h3 id="-">函数定义的方式</h3>
<h4 id="arrow-function">arrow function</h4>
<p>箭头函数中的<code>this</code>的指向不由函数执行上下文所决定，而是由函数定义时的外层作用域来决定<code>this</code></p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> (a)=&gt;{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a)
    }
}

<span class="hljs-keyword">var</span> obj1{
    a:<span class="hljs-number">2</span>
}

<span class="hljs-keyword">var</span> obj2{
    a:<span class="hljs-number">3</span>
}
<span class="hljs-keyword">var</span> bar = foo.call(obj1) <span class="hljs-comment">// foo的this绑定到obj1上，所以在返回箭头函数时，箭头函数也被绑定在obj1上。</span>
bar.call(obj2) ---&gt; <span class="hljs-number">2</span> <span class="hljs-comment">// 执行箭头函数，此时箭头函数this仍指向之前的obj1，函数执行不改变箭头函数中的`this`</span>
</code></pre><h4 id="bind">bind</h4>
<p>传入绑定的对象，并返回新的函数。此时函数中的<code>this</code>指向传入的对象</p>
<pre><code>function foo(){
    console.log(this.a)
}

<span class="hljs-keyword">var</span> obj = {
    a:<span class="hljs-number">2</span>
}

<span class="hljs-keyword">var</span> <span class="hljs-func"><span class="hljs-keyword">func</span> = <span class="hljs-title">foo</span>.<span class="hljs-title">bind</span><span class="hljs-params">(obj)</span></span>
<span class="hljs-func"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> ---&gt; <span class="hljs-number">2</span>
</code></pre></div></div><footer class="footer"><address class="author">Copyright &copy;<a rel="author" href="https://github.com/Amanda111" class="author-name">Amanda</a>-<a href="https://github.com/Amanda111/my-tech-diary" class="source-repo">Source</a></address></footer></body></html>